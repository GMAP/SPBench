/**
 * ************************************************************************  
 *  File  : lane_detection_utils.cpp
 *
 *  Title : SPBench version of the Lane Detection
 *
 *  Author: Adriano Marques Garcia <adriano1mg@gmail.com> 
 *
 *  Date  : July 06, 2021
 *
 * ************************************************************************
**/

/**
 * ------------------------------------------------------------------------------------------
 * Lane Detection:
 *
 * General idea and some code modified from:
 * chapter 7 of Computer Vision Programming using the OpenCV Library. 
 * by Robert Laganiere, Packt Publishing, 2011.
 * This program is free software; permission is hereby granted to use, copy, modify, 
 * and distribute this source code, or portions thereof, for any purpose, without fee, 
 * subject to the restriction that the copyright notice may not be removed 
 * or altered from any source or altered source distribution. 
 * The software is released on an as-is basis and without any warranties of any kind. 
 * In particular, the software is not guaranteed to be fault-tolerant or free from failure. 
 * The author disclaims all warranties with regard to this software, any use, 
 * and any consequent failure, is purely the responsibility of the user.
 *
 * Copyright (C) 2013 Jason Dorweiler, www.transistor.io
 * ------------------------------------------------------------------------------------------
 * Source:
 *
 * http://www.transistor.io/revisiting-lane-detection-using-opencv.html
 * https://github.com/jdorweiler/lane-detection
 * ------------------------------------------------------------------------------------------
 * Notes:
 * 
 * Add up number on lines that are found within a threshold of a given rho,theta and 
 * use that to determine a score.  Only lines with a good enough score are kept. 
 *
 * Calculation for the distance of the car from the center.  This should also determine
 * if the road in turning.  We might not want to be in the center of the road for a turn. 
 *
 * Several other parameters can be played with: min vote on houghp, line distance and gap.  Some
 * type of feed back loop might be good to self tune these parameters. 
 * 
 * We are still finding the Road, i.e. both left and right lanes.  we Need to set it up to find the
 * yellow divider line in the middle. 
 * 
 * Added filter on theta angle to reduce horizontal and vertical lines. 
 * 
 * Added image ROI to reduce false lines from things like trees/powerlines
 * ------------------------------------------------------------------------------------------
 */

#include <lane_detection_utils_ns.hpp>

namespace spb{

std::vector<cv::Mat> MemData; //vector to store data in-memory

std::vector<IO_data_struct> IO_data_vec;

cv::VideoWriter oVideoWriter;
cv::VideoCapture capture;

void set_operators_name(){
	//vector<string> operator_name_list;
	SPBench::addOperatorName("Source ");
	SPBench::addOperatorName("Segment");
	SPBench::addOperatorName("Canny_1");
	SPBench::addOperatorName("HoughT ");
	SPBench::addOperatorName("HoughP ");
	SPBench::addOperatorName("Bitwise");
	SPBench::addOperatorName("Canny_2");
	SPBench::addOperatorName("Overlap");
	SPBench::addOperatorName("Sink   ");
	//return operator_name_list;
}

void usage(std::string name){
	fprintf(stderr, "Usage: %s\n", name.c_str());
	fprintf(stderr, "\t-i\t: <input_video> (mandatory)\n");
	fprintf(stderr, "\t-b\t: <batch_size_in_number_of_items>\n");
	fprintf(stderr, "\t-B\t: <batch_size_in_milliseconds>\n");
	fprintf(stderr, "\t-F\t: <target_throughput>\n");
	fprintf(stderr, "\t-p\t: Frequency pattern: <pattern,period,min,max>\n");
	fprintf(stderr, "\t-t\t: <number_of_threads>\n");
	fprintf(stderr, "\t-k\t: enable in-memory execution\n");
	fprintf(stderr, "\t-l\t: print average latency results\n");
	fprintf(stderr, "\t-f\t: store individual latency values into a log file\n");
	fprintf(stderr, "\t-m\t: monitors latency, throughput, and CPU and memory usage.\n");
	fprintf(stderr, "\t-x\t: print average throughput results\n");
	fprintf(stderr, "\t-r\t: print memory consumption results generated by UPL library\n");
	fprintf(stderr, "\t-u\t: send a custom argument to be used inside your programm\n");
	fprintf(stderr, "\t-h\t: print this help message\n");
	exit(-1);
}

void init_bench(int argc, char* argv[]){

	std::string input;
	int opt;
	while ((opt = getopt(argc,argv,"i:t:b:B:m:F:u:klfxrh")) != EOF){
		switch(opt){
			case 'i':
				if(!file_exists(optarg)){
					printf("Invalid input file! Try run: %s -i <input_file>\n", argv[0]);
					exit(1);
				}
				IO_data_vec.push_back({optarg});
				break;
			case 't':
				nthreads = atoi(optarg);
				break;
			case 'b':
				if (atoi(optarg) <= 0)
					throw std::invalid_argument("\n ARGUMENT ERROR (-b <batch_size>) --> Batch size must be an integer value higher than zero!\n");
				SPBench::setBatchSize(atoi(optarg));
				break;
			case 'B':
				if (atof(optarg) <= 0.0)
					throw std::invalid_argument("\n ARGUMENT ERROR (-B <batch_interval>) --> Batch interval must be a value higher than zero!\n");
				SPBench::setBatchInterval(atof(optarg));
			case 'm':
				Metrics::set_monitoring_time_interval(atoi(optarg));
				Metrics::enable_monitoring();
				break;
			case 'F':
				if (atof(optarg) <= 0.0)
					throw std::invalid_argument("\n ARGUMENT ERROR (-F <frequency>) --> Frequency value must be higher than zero!\n");
				SPBench::setFrequency(atof(optarg));
				break;
			case 'k':
				SPBench::enable_memory_source();
				break;
			case 'l':
				Metrics::enable_print_latency();
				break;
			case 'f':
				Metrics::enable_latency_to_file();
				break;
			case 'x':
				Metrics::enable_throughput();
				break;
			case 'r':
				Metrics::enable_upl();
				break;
			case 'u':
				SPBench::setArg(optarg);
				break;
			case 'h':
				usage(argv[0]);
				break;
			case '?': 
				usage(argv[0]);
				break;
			default: 
				std::cout << std::endl; 
				exit(1);
		}
	}
	SPBench::bench_path = argv[0];
	set_operators_name();
	Metrics::enable_latency();
}

void Source::printStatus(){
	std::cout << "\n - New source added: " << getSourceName() << std::endl;
	std::cout << "             Input: " << IO_data_vec[sourceId].inputFile << std::endl;
	
	std::cout << "\n - Setup:" << std::endl;
	std::cout << "         Batch size: " << sourceBatchSize << std::endl;
	std::cout << "     Batch interval: " << sourceBatchInterval << std::endl;
	
	if(sourceQueueSize == 0)
		std::cout << "    Queue max. size: 0 (unlimited)" << std::endl;
	else
		std::cout << "    Queue max. size: " << sourceQueueSize << std::endl;

	if(sourceFrequency == 0)
		std::cout << "    Input frequency: 0 (no limit)" << std::endl;
	else
		std::cout << "    Input frequency: " << sourceFrequency << " items per second" << std::endl;

	if(SPBench::memory_source_is_enabled())
		std::cout << "In-memory execution: enabled" << std::endl;
	std::cout << "\n###############################################" << std::endl;
}

void Source::source_op(){
	
	if(!file_exists(IO_data_vec[sourceId].inputFile)){
		printf("Invalid input file! Check if the file exists or run with -h for more details.\n");
		exit(1);
	}

	cv::VideoCapture capture;

	capture.open(IO_data_vec[sourceId].inputFile);

	//if this fails, try to open as a video camera, through the use of an integer param
	if (!capture.isOpened()) 
	{capture.open(atoi(IO_data_vec[sourceId].inputFile.c_str()));}

	//get the width of frames of the video
	double dWidth = capture.get(CV_CAP_PROP_FRAME_WIDTH);
	//get the height of frames of the video 
	double dHeight = capture.get(CV_CAP_PROP_FRAME_HEIGHT); 

	cv::Size frameSize(static_cast<int>(dWidth), static_cast<int>(dHeight));

	// generate a name and path for the output file
	std::string output_file = (prepareOutFileAt("outputs") + "_" + remove_extension(base_name(IO_data_vec[sourceId].inputFile)) + ".avi");

	//initialize the VideoWriter object 
	IO_data_vec[sourceId].oVideoWriter.open(output_file.c_str(), CV_FOURCC('P','I','M','1'), 20, frameSize, true);
	
	//load the input to the memory before the stream region for in-memory execution
	if(SPBench::memory_source_is_enabled()){
		while(1){
			cv::Mat image;
			capture >> image;
			if (image.empty()) break;
			IO_data_vec[sourceId].MemData.push_back(image);
		}
	}

	unsigned int sourceItemCounter = 0;
	bool end_of_input = false;

	long source_item_timestamp = current_time_usecs();

	while(1){
		Item item;

		//if last batch included the last item, ends computation
		if(end_of_input == true){
			item.setLastItem();
			sourceQueue.enqueue(item);
			break;
		}

		// frequency control mechanism
		item_frequency_control(source_item_timestamp, sourceFrequency);

		item.timestamp = source_item_timestamp = current_time_usecs();
		unsigned long batch_elapsed_time = source_item_timestamp;
		
		unsigned long latency_op;
		item.timestamp = current_time_usecs();
		if(Metrics::latency_is_enabled()){
			latency_op = current_time_usecs();
		}
		
		while(1){ //batch loop

			// batching management routines
			if(sourceBatchInterval){
				if(((current_time_usecs() - batch_elapsed_time) / 1000.0) >= sourceBatchInterval) break;
			} else {
				if(item.batch_size >= sourceBatchSize) break;
			}
			if(sourceBatchSize > 1){
				if(item.batch_size >= sourceBatchSize) break;
			}
			item_data item_data;
			
			if(SPBench::memory_source_is_enabled()){
				if(sourceItemCounter < IO_data_vec[sourceId].MemData.size()){
					item_data.image_p = &IO_data_vec[sourceId].MemData[sourceItemCounter];
				} else {
					end_of_input = true;
					break;
				}
			} else {
				capture >> item_data.image;
				if (item_data.image.empty()){
					end_of_input = true;
					break;
				}
			}
			item.item_batch.resize(item.batch_size+1);
			item.item_batch[item.batch_size] = item_data;
			item.batch_size++;
			item.setNotEmpty();
			sourceItemCounter++;
		}
		
		//if this batch has size 0, ends computation
		if(item.batch_size == 0){
			item.setLastItem();
			sourceQueue.enqueue(item);
			break;
		}

		if(Metrics::latency_is_enabled()){
			item.latency_op.push_back(current_time_usecs() - latency_op);
		}

		// put item in the output queue
		sourceQueue.enqueue(item);
		
		// Accumulate the total number of sent batches
		metrics_vec[sourceId].global_batch_counter++;

		// Update the total number of sent items
		metrics_vec[sourceId].global_item_counter = sourceItemCounter;
	}
	
	return;
}

void Sink::op(Item &item){
	if(item.empty())
		return;

	volatile unsigned long latency_op;
	if(Metrics::latency_is_enabled()){
		latency_op = current_time_usecs();
	}

	// If in-memory is enabled, do nothing here, the result is already ready on the output vector
	// Else, then retrieve the data from items and write it on the disk
	if(!SPBench::memory_source_is_enabled()){
		unsigned int num_item = 0;
		while(num_item < item.batch_size){ //batch loop
			IO_data_vec[item.sourceId].oVideoWriter.write(item.item_batch[num_item].image);
			item.item_batch[num_item].image.release();
			num_item++;
			metrics_vec[item.sourceId].items_at_sink_counter++;
		}
	} else { // If in-memory is enabled, just count the items on the batch and proceed to the next batch
		metrics_vec[item.sourceId].items_at_sink_counter += item.batch_size;
	}

	metrics_vec[item.sourceId].batches_at_sink_counter++;

	if(Metrics::monitoring_is_enabled()){
		monitor_metrics(item.timestamp, item.sourceId);
	}
	if(Metrics::latency_is_enabled()){
		double current_time_sink = current_time_usecs();
		item.latency_op.push_back(current_time_sink - latency_op);

		volatile unsigned long total_item_latency = (current_time_sink - item.timestamp);
		metrics_vec[item.sourceId].global_latency_acc += total_item_latency; // to compute real time average latency
		
		item_metrics_data latency;
		latency.local_latency = item.latency_op;
		latency.total_latency = total_item_latency;
		latency.item_sink_timestamp = current_time_sink;
		latency.batch_size = item.batch_size;
		metrics_vec[item.sourceId].latency_vector_ns.push_back(latency);
		metrics_vec[item.sourceId].stop_throughput_clock = current_time_sink;
		item.latency_op.clear();
	}
}

void end_bench(){
	if(SPBench::memory_source_is_enabled()){
		for (auto & input : IO_data_vec){

			while(!input.MemData.empty()){
				input.oVideoWriter.write(input.MemData[0]); // always write the first data element
				input.MemData.erase(input.MemData.begin()); // erase the writen data element from memory
			}

			if(!input.MemData.empty()) // erase any trash
				input.MemData.erase(input.MemData.begin(), input.MemData.end());
		}
	}
	compute_metrics();
}

} // end of namespace spb
